{
  "subject_name": "Основы программирования",
  "catalog": [
    {
      "title": "Устные вопросы",
      "problems": [
        {
          "question": "Основные понятия языков программирования.",
          "solution": "<li><strong><span style=\"text-decoration: underline;\"><em>Основные понятия языков программирования:</em></span><br /></strong><em>Языки программирования</em> &ndash; это формальные языки созданные для общения человека с компьютером.<br />В отличии от естественных языков, правила грамматики, синтаксиса, сематики должны быть явно, однозначны и четко сформулированы. Синтаксические определения устанавливают правила построения элементов языка; семантика определяет смысл и правила использования. <br /><em>Основные понятия для языков программирования:</em><strong> 1)</strong> <em>Алфавит языка</em> &ndash; это основные неделимые знаки с помощью которого пишутся все тексты на языке C++ (буквы, цифры, пробел, символ перехода на новую строку); <strong>2)</strong> <em>Пробелом считают</em> &ndash; табуляцию, переход на новую строку, пробел; <strong>3)</strong> <em>Лексика</em> &ndash; это элементарная конструкция из символов алфавита; <strong>4)</strong> <em>Выражение</em> &ndash; это правила вычисления некоторого значения; <strong>5)</strong> <em>Оператор</em> &ndash; описывает законченное действие;<strong> 6)</strong> <em>Переменная</em> &ndash; программный объект связанный с ячейками памяти компьютера для хранения некоторого значения; <strong>7)</strong> <em>Функция</em> &ndash; это программный объект задающий последовательность действий для вычисления действий зависимого от исходных аргументов или входных параметров функции; <strong>8)</strong> <em>Модуль</em> &ndash; это специальная программная единица, т.е. код в отдельном файле предназначенный для разделения программ на связанные блоки; <strong>9)</strong> <em>Комментарий</em> &ndash; служат для описания работы программы записываются прямо в текст программы, но игнорируются компьютером.</li>",
          "type": "text"
        },
        {
          "question": "Алгоритм и его свойства. Схемы алгоритма.",
          "solution": "<p><em><span style=\"text-decoration: underline;\"><strong>&bull; Алгоритм и его свойства. Схемы алгоритма. </strong></span><br />Алгоритм</em> - это последовательность команд, предназначенная исполнителю, в результате выполнения которой он должен решить поставленную задачу. Если алгоритм предназначен для создания программы, то он должен обладать следующими свойствами: 1) <em>Детерминированность </em>&ndash; это определенность и однозначность алгоритма исключающая двусмысленность; 2) <em>Массовость - </em>позволяет использовать один алгоритм множество раз с любым исходными данными; 3) <em>Результативность </em>&ndash; предполагает получение результата при любых исходных данных за конечное время; 4) <em>Практическая осуществимость</em> &ndash; э то возможность решения задачи на конкретном компьютере в допустимые сроки.</p>",
          "type": "text"
        },
        {
          "question": "Базовые алгоритмические структуры.",
          "solution": "<p><strong><em><u>Базовые алгоритмические структуры.<br /></u></em></strong>Алгоритмы можно представлять как некоторые структуры, состоящие из отдельных базовых (т.е. основных) элементов. Естественно, что при таком подходе к алгоритмам изучение основных принципов их конструирования должно начинаться с изучения этих базовых элементов. Характерной особенностью базовых структур является наличие в них одного входа и одного выхода.<br />1) <em>Базовая структура\"следование\"</em> - образуется последовательностью действий, следующих одно за другим: <br/><img src=\"/static/images/2q-1o.png\" alt=\"\" /><br />2) <em>Базовая структура\"ветвление\"</em> - обеспечивает в зависимости от результата проверки условия (да или нет) выбор одного из альтернативных путей работы алгоритма. Каждый из путей ведет к общему выходу, так что работа алгоритма будет продолжаться независимо от того, какой путь будет выбран. Структура ветвление существует в четырех основных вариантах: если&mdash;то, если&mdash;то&mdash;иначе, выбор, выбор&mdash;иначе: <br/><img src=\"/static/images/2q-2o.png\" alt=\"\" /><br />3) <em>Базовая структура\"цикл\"</em> - обеспечивает многократное выполнение некоторой совокупности действий, которая называется телом цикла:<br/><img src=\"/static/images/2q-3o.png\" alt=\"\" /></p>",
          "type": "text"
        },
        {
          "question": "Виды языков программирования.",
          "solution": "<p><strong><em><u>Виды языков программирования.</u></em></strong> <br />Все языки условно разделяют на <em>процедурные(алгоритмические)</em> и <em>непроцедурные</em>. <em>Процедурные(алгоритмические)</em> &ndash; предназначены для написания программ в виде системы команд для решения конкретной задачи; <br /><em>Процедурные(алгоритмические)</em> разделяются на <em>высокий</em> и <em>низкий</em> уровень: <em>Низкий уровень</em> &ndash; ориентирован на конкретный тип процессора и использует его команды, а операторы представляют собой лексемы соответствующие машинному коду команд процессора (assembler). <em>Недостаток</em> &ndash; решение простых задач требует большого количества команд. <em>Достоинства</em> &ndash; программа занимает меньше места в памяти и работает быстрее. Для них не нужны системы программирования с компиляторами. Используют для написания ядра ОС, системных программ, драйверов и т.д.; <em>Высокий</em> <em>уровень</em> &ndash; если язык имитирует естественный и обладает командами ориентированными на решение прикладных задач. <em>Достоинства</em> &ndash; набор операций не зависит от команд процессора и удобен для решения. <em>Недостаток</em> &ndash; необходим компилятор, программа прошедшая компиляцию занимает больше места и работает медленнее чем на языке низкого уровня. <br /><em>Непроцедурные языки</em> &ndash; программа которая не является алгоритмической последовательностью действий: 1)<em>объектные</em>; 2) <em>декларативные</em>; <em>Объектные</em> представляют собой виртуальную реальность в виде множества объектов, каждый из которых обладает своими свойствами и поведением, и чаще всего моделируют реальный объект. <em>Декларативные</em> &ndash; указывают исходные информационную структуру, взаимосвязи между ними и свойствами будущего результата, в этих языках отсутствует понятие &laquo;оператор&raquo;.</p>",
          "type": "text"
        },
        {
          "question": "Системы программирования.",
          "solution": "<p><strong><em><u>Системы программирования.<br /></u></em></strong><em>Системы программирования</em> &ndash; это комплекс инструментальных программных средств предназначенные для работы с программой на одном или нескольких языках программирования.<br />Составляющие системы программирования: 1) <em>Трансляторы</em> с языков высокого уровня; 2) <em>Компилятор</em> &ndash; полностью обрабатывает весь текст; 3) <em>Интерпретатор</em> &ndash; переводит в машинный код каждый оператор отдельно параллельно с выполнением программы, при этом контролирует состояние окружающей программной аппаратной среды; 4) <em>Отладчик</em> &ndash; выполняет сервисные функции по отладке и тестированию программы; 5) <em>Тестовый</em> <em>редактор</em> &ndash; необходим для набора исходного кода без служебных символов плюс дополнительная проверка синтаксиса; 6) <em>Средства</em> <em>компоновки</em> <em>и</em> <em>загрузки</em>; 7) <em>Марко</em> <em>ассемблеры</em> &ndash; возможность вставлять в код низкоуровневые команды, код ассемблера.</p>",
          "type": "text"
        },
        {
          "question": "Жизненный цикл программного средства.",
          "solution": "<p><strong><em><u>Жизненный цикл программного средства.</u></em></strong> &nbsp;<br /><em>Жизненный цикл программного обеспечения (ПО) </em>&mdash; период времени, который начинается с момента принятия решения о необходимости создания программного продукта и заканчивается в момент его полного изъятия из эксплуатации. В соответствии с данным стандартом жизненный цикл программных средств состоит из процессов. Процессы ЖЦ ПС делятся на следующие группы: <em>основные</em>, <em>вспомогательные</em>, <em>организационные</em>; <br />К основным процессам ЖЦ относятся следующие процессы: <em>заказ</em>, <em>поставка</em>, <em>разработка</em>, <em>эксплуатация</em>, <em>сопровождение</em>. <em>Процесс разработки<strong>&nbsp;</strong></em>состоит из работ и выполняемых задач разработчиком, и включает работы по анализу требований, проектированию, программированию, сборке, тестированию, вводу в действие и приемке ПС. Процесс разработки содержит&nbsp;<em>тринадцать работ</em>: 1) подготовка процесса разработки; 2) анализ требований к системе; 3 )проектирование системной архитектуры; 4) анализ требований к программным средствам; 5) проектирование программной архитектуры; 6) техническое проектирование программных средств; 7) программирование и тестирование программных средств; 8) сборка программных средств; 9) квалификационные испытания программных средств; 10) сборка системы; 11) квалификационные испытания системы; 12) ввод в действие программных средств; 13) обеспечение приемки программных средств. В процессе разработки программного средства различают <em>два вида работ</em>: системные и программные.&nbsp;<em>Системные работы&nbsp;</em>начинают и завершают процесс разработки. К данным работам относятся следующие: 2) анализ требований к системе; 3) проектирование системной архитектуры; 10) сборка системы; 11) квалификационные испытания системы.</p>",
          "type": "text"
        },
        {
          "question": "Структура программы на языке C++. Операторы ввода-вывода.",
          "solution": "<p><span>Программа на С++ состоит из набора инструкций. Каждая инструкция (statement) выполняет определенное действие. В конце инструкции в языке C++ ставится точка с запятой (;).</span></p>\n<p><span>Каждая программа на языке С++ должна иметь как минимум одну функцию - функцию&nbsp;</span><span class=\"b\">main()</span><span>. Именно с этой функции начинается выполнение приложения. Ее имя&nbsp;</span><span class=\"b\">main</span><span>&nbsp;фиксировано и для всех программ на Си всегда одинаково.</span></p>\n<p><span>int main()</span></p>\n<p><span>{</span></p>\n<p><span>}</span></p>\n<p>Определение функии main начинается с возвращаемого типа. Функция main в любом случае должна возвращать число. Поэтому ее определение начинается с ключевого слова<span>&nbsp;</span><span class=\"b\">int</span>.</p>\n<p>Далее идет название функции, то есть<span>&nbsp;</span><span class=\"b\">main</span>. После названия в скобках идет список параметров. В данном случае функция main не принимает никаких параметров, поэтому после названия указаны пустые скобки.</p>\n<p>Для использования объектно-ориентированного консольного ввода-вывода с&nbsp;помощью потоков (stream) STL в&nbsp;программу необходимо включить заголовочный файл<span>&nbsp;</span><code>&lt;iostream&gt;</code>, а&nbsp;для файлового ещё и<span>&nbsp;</span><code>&lt;fstream&gt;</code>. (Разумеется, компилятор должен иметь доступ к&nbsp;соответствующей объектной библиотеке для правильной сборки исполняемого файла.)</p>\n<p>Самая простая программа с&nbsp;использованием потоков STL выглядит так:</p>\n<pre><code class=\"cpp hljs\"><span class=\"hljs-preprocessor\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"Hello, world!\"</span>;\n}</code><br /><br /><br />cout &lt;&lt; ...; //вывод<br />cin &gt;&gt; ...; //ввод</pre>",
          "type": "text"
        },
        {
          "question": "Типы данных в C++. Оператор присваивания.",
          "solution": "<div class=\"co8aDb XcVN5d\" aria-level=\"3\" role=\"heading\"><b>Основные<span>&nbsp;</span>типы данных<span>&nbsp;</span>в C++</b></div>\n<div class=\"RqBzHd\">\n<ul class=\"i8Z77e\">\n<li class=\"TrT0Xe\">int &mdash; целочисленный<span>&nbsp;</span><b>тип данных</b>.</li>\n<li class=\"TrT0Xe\">float &mdash;<span>&nbsp;</span><b>тип данных</b><span>&nbsp;</span>с плавающей запятой.</li>\n<li class=\"TrT0Xe\">double &mdash;<span>&nbsp;</span><b>тип данных</b><span>&nbsp;</span>с плавающей запятой двойной точности.</li>\n<li class=\"TrT0Xe\">char &mdash; символьный<span>&nbsp;</span><b>тип данных</b>.</li>\n<li class=\"TrT0Xe\">bool &mdash; логический<span>&nbsp;</span><b>тип данных</b>.</li>\n</ul>\n<p><span>Объявление переменной в C++ происходит таким образом: сначала указывается тип данных для этой переменной а затем название этой переменной</span></p>\n<p><span>Пример объявления переменных:</span></p>\n<p><span><span class=\"hljs-keyword\">int</span> a; <span class=\"hljs-comment\">// объявление переменной a целого типа. </span></span></p>\n<p><span> <span class=\"hljs-keyword\">float</span> b; <span class=\"hljs-comment\">// объявление переменной b типа данных с плавающей запятой. </span></span></p>\n<p><span> <span class=\"hljs-keyword\">double</span> c = <span class=\"hljs-number\">14.2</span>; <span class=\"hljs-comment\">// инициализация переменной типа double. </span></span></p>\n<p><span> <span class=\"hljs-keyword\">char</span> d = <span class=\"hljs-string\">'s'</span>; <span class=\"hljs-comment\">// инициализация переменной типа char. </span></span></p>\n<p><span> <span class=\"hljs-keyword\">bool</span> k = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// инициализация логической переменной k.</span></span></p>\n<p><span><span class=\"hljs-comment\">C++&nbsp;<strong>оператор присваивания</strong>&nbsp;<strong><code>(=)</code></strong>&nbsp;&mdash; не является знаком равенства и не может использоваться для сравнения значений. Оператор равенства записывается как &laquo;двойное равно&raquo; &mdash;&nbsp;<code>==</code>.</span></span></p>\n<p><span><span class=\"hljs-comment\">Присваивание используется для сохранения определенного значение в переменной. Например, запись вида&nbsp;<code>a = 10</code>&nbsp;задает переменной&nbsp;<code>a</code>&nbsp;значение числа 10.</span></span></p>\n</div>",
          "type": "text"
        },
        {
          "question": "Бинарные и унарные операции, математические функции.",
          "solution": "<p><strong><em><u>Бинарные и унарные операции, математические функции.<br /></u></em></strong><em>Операция</em> &mdash; конструкция в языках программирования, аналогичная по записи математическим операциям, то есть специальный способ записи некоторых действий. Наиболее часто применяются арифметические, логические и строковые операции. В отличие от функций, операции часто являются базовыми элементами языка и обозначаются различными символами пунктуации, а не алфавитно-цифровыми; они имеют специальный инфиксный синтаксис и нестандартные правила передачи аргументов. Терминология, однако, несколько отличается от языка к языку. Фактически<em>, операция</em> &mdash; это та же функция, но записываемая особым образом. По этой причине логично иметь возможность определять операции для произвольных типов таким же образом, как и методы &mdash; чтобы можно было работать с ними точно так же, как и с элементарными типами. Эта возможность называется &laquo;перегрузка операций&raquo; и присутствует в большинстве языков 4&mdash;5 поколений. В таких языках транслятор фактически подставляет вместо выполнения операции вызов соответствующей ей функции. Операции делятся по количеству принимаемых аргументов на: <em>унарные</em> &mdash; один аргумент (отрицание, унарный минус); <em>бинарные</em> &mdash; два аргумента (сложение, вычитание, умножение и т. д.); <em>тернарные</em> &mdash; три аргумента (&laquo;условие ? выражение1 : выражение2&raquo;).</p>",
          "type": "text"
        },
        {
          "question": "Оператор условного перехода. Логические операции.",
          "solution": "<div class=\"line number19 index18 alt2\"><span>Оператор условного перехода&nbsp;</span><span>if</span><span>&nbsp;позволяет организовать выбор хода выполнения программы. Выбор осуществляется по некоторому условию. Если условие выполняется, тогда выполнение программы происходит одним путем. Иначе, программа выполняется другим путем.</span></div>\n<div class=\"line number19 index18 alt2\"><span>Общий вид полной формы оператора условного перехода&nbsp;if:</span></div>\n<div class=\"line number19 index18 alt2\">\n<pre><span>if</span> (<em>выражение</em>)\n{\n<span>// несколько операторов (инструкций)</span>\n}\n<span>else</span>\n{\n<span>// несколько операторов (инструкций)</span>\n}<br /><br /></pre>\n<p>Оператор<span>&nbsp;</span><span>if</span><span>&nbsp;</span>работает следующим образом. Если элемент выражение дает значение<span>&nbsp;</span><span>true</span><span>&nbsp;</span>(истина), тогда выполняются операторы сразу после слова<span>&nbsp;</span><span>if.</span><span>&nbsp;</span>В противном случае (значение выражения равно<span>&nbsp;</span><span>false)</span><span>&nbsp;</span>выполняются операторы, следующие после слова<span>&nbsp;</span><span>else.</span></p>\n<p>Если после слова if или после слова<span>&nbsp;</span><span>else</span><span>&nbsp;</span>нужно выполнить только один оператор (а не несколько), тогда фигурные скобки<span>&nbsp;</span><span>{ }</span><span>&nbsp;</span>можно опустить.</p>\n<pre><span>if</span> (<em>выражение</em>)\nоператор1;\n<span>else</span>\nоператор2;</pre>\n</div>",
          "type": "text"
        },
        {
          "question": "Оператор множественного выбора.",
          "solution": "<p><span data-ttu-id=\"60343-104\">Операторы&nbsp;<strong><code>switch</code></strong>&nbsp;и&nbsp;<strong><code>case</code></strong>&nbsp;помогают управлять сложными условными операциями и операциями ветвления.</span><span>&nbsp;</span><span data-ttu-id=\"60343-105\">Оператор&nbsp;<strong><code>switch</code></strong>&nbsp;передает управление в оператор внутри своего тела.</span></p>\n<div class=\"line number2 index1 alt1\"><code class=\"cpp keyword bold\">switch</code> <code class=\"cpp plain\">(</code><code class=\"cpp comments\">/*переменная или выражение*/</code><code class=\"cpp plain\">)</code></div>\n<div class=\"line number3 index2 alt2\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp plain\">{</code></div>\n<div class=\"line number4 index3 alt1\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp keyword bold\">case</code> <code class=\"cpp comments\">/*константное выражение1/*:</code></div>\n<div class=\"line number5 index4 alt2\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp comments\">{</code></div>\n<div class=\"line number6 index5 alt1\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp comments\">/*группа операторов*/</code><code class=\"cpp plain\">;</code></div>\n<div class=\"line number7 index6 alt2\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp keyword bold\">break</code><code class=\"cpp plain\">;</code></div>\n<div class=\"line number8 index7 alt1\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp plain\">}</code></div>\n<div class=\"line number9 index8 alt2\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp keyword bold\">case</code> <code class=\"cpp comments\">/*константное выражение2*/</code><code class=\"cpp plain\">:</code></div>\n<div class=\"line number10 index9 alt1\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp plain\">{</code></div>\n<div class=\"line number11 index10 alt2\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp comments\">/*группа операторов*/</code><code class=\"cpp plain\">;</code></div>\n<div class=\"line number12 index11 alt1\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp keyword bold\">break</code><code class=\"cpp plain\">;</code></div>\n<div class=\"line number13 index12 alt2\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp plain\">}</code></div>\n<div class=\"line number14 index13 alt1\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp comments\">//.&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; .</code></div>\n<div class=\"line number15 index14 alt2\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp keyword bold\">default</code><code class=\"cpp plain\">:</code></div>\n<div class=\"line number16 index15 alt1\"><code class=\"cpp plain\">&nbsp;{</code></div>\n<div class=\"line number17 index16 alt2\"><code class=\"cpp spaces\">&nbsp; </code><code class=\"cpp comments\">/*группа операторов*/</code><code class=\"cpp plain\">;</code></div>\n<div class=\"line number18 index17 alt1\"><code class=\"cpp plain\">&nbsp;}</code></div>\n<div class=\"line number19 index18 alt2\"><code class=\"cpp spaces\">&nbsp;</code><code class=\"cpp plain\">}</code></div>\n<div class=\"line number19 index18 alt2\">\n<p>Первый тип лейбла &mdash; это<span>&nbsp;</span><strong>case<span>&nbsp;</span></strong>(или просто<span>&nbsp;</span><em><strong>&laquo;кейс&raquo;</strong></em>), который объявляется с использованием<span>&nbsp;</span><strong>ключевого слова</strong><span>&nbsp;</span><strong>case</strong><span>&nbsp;</span>и имеет константное выражение. Константное выражение &mdash; это то, которое генерирует константное значение, другими словами: либо<span>&nbsp;тиерал</span><span>&nbsp;</span>(например,<span>&nbsp;</span><code>5</code>), либо<span>&nbsp;перечисление</span><span>&nbsp;</span>(например,<span>&nbsp;</span><code>COLOR_RED</code>), либо<span>&nbsp;константу</span><span>&nbsp;</span>(например, переменную<span>&nbsp;</span><code>x</code>, которая была объявлена с ключевым словом const).</p>\n<p>Константное выражение, находящееся после ключевого слова case, проверяется на равенство с выражением, находящимся возле ключевого слова switch. Если они совпадают, то тогда выполняется код под\n \nсоответствующим кейсом.</p>\n<p></p>\n<p><span>Второй тип лейбла &mdash; это&nbsp;</span><strong>лейбл по умолчанию</strong><span>&nbsp;(так называемый&nbsp;</span><em><strong>&laquo;default case&raquo;</strong></em><span>), который объявляется с использованием&nbsp;</span><strong>ключевого слова default</strong><span>. Код под этим лейблом выполняется, если ни один из кейсов не соответствует выражению switch. Лейбл по умолчанию является необязательным. В одном switch может быть только один default. Обычно его объявляют самым последним в блоке switch.</span></p>\n<code class=\"cpp plain\"></code></div>",
          "type": "text"
        },
        {
          "question": "Операторы циклов с предусловием и постусловием.",
          "solution": "<p><span>Цикл while является оператором потока управления, который позволяет многократно выполнять код в зависимости от заданного логического условия.</span></p>\n<p><span>Синтаксис цикла&nbsp;<strong>while</strong>&nbsp;в C++ выглядит следующим образом.</span></p>\n<p><span><span class=\"hljs-tag\">while</span> (Условие) </span></p>\n<p><span>{</span></p>\n<p><span> Тело цикла;</span></p>\n<p><span> }</span></p>\n<p><span>Данный цикл будет выполняться, пока условие, указанное в круглых скобках является истиной. Решим ту же задачу с помощью цикла&nbsp;<strong>while</strong>. Хотя здесь мы точно знаем, сколько итераций должен выполнить цикл, очень часто бывают ситуации, когда это значение неизвестно</span></p>\n<p><span>Цикл&nbsp;<code>do&nbsp;while</code>&nbsp;отличается от цикла while тем, что в&nbsp;<code>do while</code>&nbsp;сначала выполняется тело цикла, а затем проверяется условие продолжения цикла. Из-за такой особенности&nbsp;<code>do while</code>&nbsp;называют циклом с постусловием. Таким образом, если условие&nbsp;<code>do while</code>&nbsp;заведомо ложное, то хотя бы один раз блок операторов в теле цикла&nbsp;<code>do while</code>&nbsp;выполнится. В итоге&nbsp;<code>do while</code>&nbsp;отличается от цикла&nbsp;<code>while</code>&nbsp;структурой. Если в&nbsp;<code>while</code>&nbsp;сначала выполняется проверка условия продолжения цикла, и если условие истинно, то только тогда выполняется тело цикла. Цикл<strong>&nbsp;</strong><code>do while</code><strong>&nbsp;</strong>работает с<strong>&nbsp;</strong>точностью до наоборот, сначала выполняется тело цикла, а потом проверяется условие, вот почему&nbsp; тело цикла&nbsp;<code>do while</code>, хотя бы раз, выполнится.</span></p>\n<p><span>Форма записи оператора цикла do while:</span></p>\n<div class=\"line number2 index1 alt1\"><code class=\"cpp keyword bold\">do</code>&nbsp;</div>\n<div class=\"line number3 index2 alt2\"><code class=\"cpp plain\">{</code></div>\n<div class=\"line number4 index3 alt1\"><code class=\"cpp plain\">Тело цикла;</code></div>\n<div class=\"line number5 index4 alt2\"><code class=\"cpp plain\">}</code></div>\n<div class=\"line number6 index5 alt1\"><code class=\"cpp keyword bold\">while</code> <code class=\"cpp plain\">(Условие</code><code class=\"cpp plain\">);</code></div>",
          "type": "text"
        },
        {
          "question": "Оператор цикла с параметрами.",
          "solution": "<p><b>Цикл с параметром</b><span>&nbsp;- это&nbsp;</span><b>цикл</b><span>, в котором переменная изменяет свое значение от начального значения до конечного с шагом 1 и для каждого из значений переменной выполняется&nbsp;</span><b>цикл</b><span>. ... i - параметр&nbsp;</span><b>цикла</b><span>, т. е переменная, которая меняет свое значение при каждом входе в&nbsp;</span><b>цикл</b><span>.</span></p>\n<p><span>Синтаксис:</span></p>\n<p><span><code>for (объявление переменных; условие; инкремент/декремент счетчика)</code></span></p>\n<p><span><code>{</code><br /><code>&nbsp; &nbsp; //тело цикла</code></span></p>\n<p>}</p>",
          "type": "text"
        },
        {
          "question": "Операторы break, continue, безусловный переход.",
          "solution": "<p>break&nbsp;<span data-ttu-id=\"eb914-104\">Оператор завершает выполнение ближайшего включающего цикла или условного оператора, в котором он отображается.</span><span>&nbsp;</span><span data-ttu-id=\"eb914-105\">Управление передается оператору, который расположен после оператора, при его наличии.</span></p>\n<p><span>Оператор&nbsp;</span><code>continue<strong></strong></code><strong>&nbsp;</strong><span>используется только в циклах. В операторах&nbsp;</span><code>for</code><span>,&nbsp;</span><code>while</code><span>,&nbsp;</span><code>do while</code><strong>,&nbsp;</strong><span>оператор&nbsp;</span><code>continue<strong></strong></code><strong>&nbsp;</strong><span>выполняет пропуск оставшейся части кода тела цикла и переходит к следующей итерации цикла. Рассмотрим фрагмент кода с оператором&nbsp;</span><code>continue</code><span>.</span>&nbsp;</p>\n<p><strong>Оператор<span>&nbsp;</span></strong><strong>goto</strong><span>&nbsp;&mdash; это оператор управления потоком выполнения программ</span><span>, который заставляет центральный процессор выполнить переход из одного участка кода в другой (осуществить прыжок). Другой участок кода идентифицируется с помощью&nbsp;</span><strong>лейбла</strong></p>\n<p>пример:</p>\n<div class=\"crayon-line\" id=\"crayon-5ff089c1519c6945756182-1\"><span class=\"crayon-p\">#include &lt;iostream&gt;</span></div>\n<div class=\"crayon-line crayon-striped-line\" id=\"crayon-5ff089c1519c6945756182-2\"><span class=\"crayon-p\">#include &lt;cmath&gt; // для функции sqrt()</span></div>\n<div class=\"crayon-line crayon-striped-line\"><span class=\"crayon-p\">using namespace std;</span></div>\n<div class=\"crayon-line\" id=\"crayon-5ff089c1519c6945756182-3\"><span class=\"crayon-h\"> </span></div>\n<div class=\"crayon-line crayon-striped-line\" id=\"crayon-5ff089c1519c6945756182-4\"><span class=\"crayon-t\">int</span><span class=\"crayon-h\"> </span><span class=\"crayon-e\">main</span><span class=\"crayon-sy\">(</span><span class=\"crayon-sy\">)</span></div>\n<div class=\"crayon-line\" id=\"crayon-5ff089c1519c6945756182-5\"><span class=\"crayon-sy\">{</span></div>\n<div class=\"crayon-line crayon-striped-line\" id=\"crayon-5ff089c1519c6945756182-6\"><span class=\"crayon-h\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"crayon-t\">double</span><span class=\"crayon-h\"> </span><span class=\"crayon-v\">z</span><span class=\"crayon-sy\">;</span></div>\n<div class=\"crayon-line\" id=\"crayon-5ff089c1519c6945756182-7\"><span class=\"crayon-v\">tryAgain</span><span class=\"crayon-o\">:</span><span class=\"crayon-h\"> </span><span class=\"crayon-c\">// это лейбл</span></div>\n<div class=\"crayon-line crayon-striped-line\" id=\"crayon-5ff089c1519c6945756182-8\"><span class=\"crayon-h\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"crayon-v\">cout</span><span class=\"crayon-h\"> </span><span class=\"crayon-o\">&lt;&lt;</span><span class=\"crayon-h\"> </span><span class=\"crayon-s\">\"Enter a non-negative number: \"</span><span class=\"crayon-sy\">;</span><span class=\"crayon-h\"> </span></div>\n<div class=\"crayon-line\" id=\"crayon-5ff089c1519c6945756182-9\"><span class=\"crayon-h\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"crayon-v\">cin</span><span class=\"crayon-h\"> </span><span class=\"crayon-o\">&gt;&gt;</span><span class=\"crayon-h\"> </span><span class=\"crayon-v\">z</span><span class=\"crayon-sy\">;</span></div>\n<div class=\"crayon-line crayon-striped-line\" id=\"crayon-5ff089c1519c6945756182-10\"><span class=\"crayon-h\"> </span></div>\n<div class=\"crayon-line\" id=\"crayon-5ff089c1519c6945756182-11\"><span class=\"crayon-h\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"crayon-st\">if</span><span class=\"crayon-h\"> </span><span class=\"crayon-sy\">(</span><span class=\"crayon-v\">z</span><span class=\"crayon-h\"> </span><span class=\"crayon-o\">&lt;</span><span class=\"crayon-h\"> </span><span class=\"crayon-cn\">0.0</span><span class=\"crayon-sy\">)</span></div>\n<div class=\"crayon-line crayon-striped-line\" id=\"crayon-5ff089c1519c6945756182-12\"><span class=\"crayon-h\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"crayon-st\">goto</span><span class=\"crayon-h\"> </span><span class=\"crayon-v\">tryAgain</span><span\n \nclass=\"crayon-sy\">;</span><span class=\"crayon-h\"> </span><span class=\"crayon-c\">// а это оператор goto </span></div>\n<div class=\"crayon-line\" id=\"crayon-5ff089c1519c6945756182-13\"><span class=\"crayon-h\"> </span></div>\n<div class=\"crayon-line crayon-striped-line\" id=\"crayon-5ff089c1519c6945756182-14\"><span class=\"crayon-h\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"crayon-v\">cout</span><span class=\"crayon-h\"> </span><span class=\"crayon-o\">&lt;&lt;</span><span class=\"crayon-h\"> </span><span class=\"crayon-s\">\"The sqrt of \"</span><span class=\"crayon-h\"> </span><span class=\"crayon-o\">&lt;&lt;</span><span class=\"crayon-h\"> </span><span class=\"crayon-v\">z</span><span class=\"crayon-h\"> </span><span class=\"crayon-o\">&lt;&lt;</span><span class=\"crayon-h\"> </span><span class=\"crayon-s\">\" is \"</span><span class=\"crayon-h\"> </span><span class=\"crayon-o\">&lt;&lt;</span><span class=\"crayon-h\"> </span><span class=\"crayon-e\">sqrt</span><span class=\"crayon-sy\">(</span><span class=\"crayon-v\">z</span><span class=\"crayon-sy\">)</span><span class=\"crayon-h\"> </span><span class=\"crayon-o\">&lt;&lt;</span><span class=\"crayon-h\"> </span><span class=\"crayon-v\">std</span><span class=\"crayon-o\">::</span><span class=\"crayon-v\">endl</span><span class=\"crayon-sy\">;</span></div>\n<div class=\"crayon-line\" id=\"crayon-5ff089c1519c6945756182-15\"><span class=\"crayon-h\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"crayon-st\">return</span><span class=\"crayon-h\"> </span><span class=\"crayon-cn\">0</span><span class=\"crayon-sy\">;</span></div>",
          "type": "text"
        },
        {
          "question": "Массивы. Генератор случайных чисел.",
          "solution": "<p><b>Массив</b><span>&nbsp;&mdash; упорядоченный набор элементов, каждый из которых хранит одно значение, идентифицируемое с помощью одного или нескольких индексов.</span></p>\n<p><span>Синтаксис объявления одномерного статического массива:</span></p>\n<p><span>тип имя_массива[размер] = {элем_1, элем_2,..., элем_n};</span></p>\n<p><span><b>Двумерный массив</b>- это одномерный&nbsp;<b>массив</b>, у которого типом компоненты является одномерный&nbsp;<b>массив</b>.&nbsp;<b>Двумерный массив</b>&nbsp;можно представить в виде квадратной или прямоугольной таблицы, состоящей из строк и столбцов.</span></p>\n<p><span>Синтаксис объявления двумерного статического массива:</span></p>\n<p><span>тип имя_массива[m][n] = {</span></p>\n<p><span>{элем_1, элем_2, ..., элем_n},</span></p>\n<p><span>{элем_1, элем_2, ..., элем_n},</span></p>\n<p><span>...</span></p>\n<p><span>{элем_1, элем_2, ..., элем_n}};</span></p>\n<p><span><b>Динамическим</b>&nbsp;называется&nbsp;<b>массив</b>, размер которого может изменяться во время исполнения программы.</span></p>\n<p><span>Синтаксис динамического одномерного массива:</span></p>\n<p><span>тип* имя_массива = new тип[размер];</span></p>\n<p><span>Генератор случайных чисел:</span></p>\n<p><span><strong>Генератор псевдослучайных чисел</strong>&nbsp;(сокр.&nbsp;<em><strong>&laquo;ГПСЧ&raquo;</strong></em>) &mdash; это программа, которая принимает стартовое/начальное значение и выполняет с ним определенные математические операции, чтобы конвертировать его в другое число, которое совсем не связано со стартовым. Затем программа использует новое сгенерированное значение и выполняет с ним те же математические операции, что и с начальным числом, чтобы конвертировать его в еще одно новое число &mdash; третье, которое не связано ни с первым, ни со вторым. Применяя этот алгоритм к последнему сгенерированному значению, программа может генерировать целый ряд новых чисел, которые будут казаться случайными (при условии, что алгоритм будет достаточно сложным).</span></p>\n<p><span>Пример программы с генератором случайных чисел:</span></p>\n<p><span>#include&lt;ctime&gt;</span></p>\n<p><span>#include&lt;iostream&gt;</span></p>\n<p><span>using namespace std;</span></p>\n<p><span>void main(){</span></p>\n<p><span>&nbsp; &nbsp;srand(time(0));</span></p>\n<p><span>&nbsp; &nbsp;cout &lt;&lt; rand();</span></p>\n<p><span>}</span></p>",
          "type": "text"
        }
      ]
    },
    {
      "title": "Практические задания",
      "problems": [
        {
          "question": "Пользователь задает два катета прямоугольного треугольника. Найти углы в градусах и гипотенузу.",
          "solution": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\tdouble a, b;\n\tcin >> a >> b;\n\t\n\tdouble ang_1 = atan(a / b) / M_PI * 180.;\n\tdouble ang_2 = atan(b / a) / M_PI * 180.;\n\tdouble c = sqrt(a * a + b * b);\n\t\n\tcout\n\t\t<< \"Угол 1: \" << ang_1 << \"°\" << endl\n\t\t<< \"Угол 2: \" << ang_2 << \"°\" << endl\n\t\t<< \"Гипотенуза: \" << c << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Пользователь задает катет и гипотенузу прямоугольного треугольника. Найти углы в градусах и второй катет.",
          "solution": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\t\n\tdouble a, b, c, alpha, beta;\n\tcin >> a >> c;\n\n\tb = sqrt(c * c - a * a);\n\n\talpha = asin(a / c) * 180. / M_PI;\n\tbeta = 90. - alpha;\n\tcout\n\t\t<< \"Угол 1: \" << alpha << \"°\" << endl\n\t\t<< \"Угол 2: \" << beta  << \"°\" << endl\n\t\t<< \"Второй катет: \" << b << endl;\n\t\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Пользователь задает гипотенузу и угол в градусах прямоугольного треугольника. Найти катеты и второй угол.",
          "solution": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\t\n\tdouble a, b, c, alpha, beta;\n\n\tcin >> c >> alpha;\n\n\ta = sin(alpha * M_PI / 180) * c;\n\tb = cos(alpha * M_PI / 180) * c;\n\tbeta = 90. - alpha;\n\n\tcout\n\t\t<< \"Катет a: \" << a << endl\n\t\t<< \"Катет b: \" << b << endl\n\t\t<< \"Угол 2: \"  << beta << endl;\n\t\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Пользователь задает параметры квадратного уравнения (a, b, c). Найти корни или вывести сообщение “нет корней”.",
          "solution": "#define _USE_MATH_DEFINES\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tdouble a, b, c, D, x1, x2;\n\n\tcin >> a >> b >> c;\n\n\tD = b * b - 4 * a * c;\n\tif (D < 0) {\n\t\tcout << \"Нет корней\" << endl;\n\t}\n\telse if (D == 0) {\n\t\tx1 = (-1. * b) / (2. * a);\n\t\tcout\n\t\t\t<< \"Сущ-ет 1 корень:\" << endl\n\t\t\t<< \"x1 = \" << x1 << endl;\n\t}\n\telse if (D > 0) {\n\t\tx1 = (-1. * b + sqrt(D)) / (2. * a);\n\t\tx2 = (-1. * b - sqrt(D)) / (2. * a);\n\t\tcout\n\t\t\t<< \"Сущ-ет 2 корня:\" << endl\n\t\t\t<< \"x1 = \" << x1 << endl\n\t\t\t<< \"x2 = \" << x2 << endl;\n\t}\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Пользователь задает три стороны треугольника. Определить существует ли треугольник. Для существующего треугольника определить его вид (разносторонний, равнобедренный, равносторонний).",
          "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tdouble a, b, c;\n\tcin >> a >> b >> c;\n\n\tif (a + b > c && a + c > b && b + c > a) {\n\t\tcout << \"Треугольник существует\" << endl;\n\t\tif (a == b && b == c)\n\t\t\tcout << \"Треугольник равносторонний\" << endl;\n\t\telse if (a == b || a == c || b == c)\n\t\t\tcout << \"Треугольник равнобедренный\" << endl;\n\t\telse\n\t\t\tcout << \"Трегольник разносторонний\"  << endl;\n\t}\n\telse {\n\t\tcout << \"Такого треугольника нет\"  << endl;\n\t}\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Пользователь задает два числа и знак математической операции (+, -, *, /). Найти результат соответствующего математического выражения. Использовать оператор выбора.",
          "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tdouble a, b;\n\tchar act;\n\tcin >> a >> act >> b;\n\n\tswitch (act) {\n\tcase '+':\n\t\tcout << a + b << endl;\n\t\tbreak;\n\tcase '-':\n\t\tcout << a - b << endl;\n\t\tbreak;\n\tcase '*':\n\t\tcout << a * b << endl;\n\t\tbreak;\n\tcase '/':\n\t\tcout << a / b << endl;\n\t\tbreak;\n\t}\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Найти сумму ряда вида 1+1/2+1/4+1/8+… Количество слагаемых задает пользователь.",
          "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tint n;\n\tcin >> n;\n\n\tdouble s = 0., x = 1.;\n\n\tfor (int i = 0; i < n; i++) {\n\t\ts += 1. / x;\n\t\tx *= 2;\n\t}\n\tcout << s << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Пользователь задает число. Найти факториал числа.",
          "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tint n;\n\tlong long fact = 1;\n\tcin >> n;\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tfact *= (long long)i;\n\t}\n\tcout << fact << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Пользователь задает число. Определить является ли число простым.",
          "solution": "#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tint n;\n\tbool isPrime = true;\n\tcin >> n;\n\n\tfor (int i = 2; i <= sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tcout << \"Число \" << n << \" - составное\";\n\t\t\tisPrime = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (isPrime) {\n\t\tcout << \"Число \" << n << \" - простое\";\n\t}\n\n\tcout << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Одномерный массив из 10 элементов задается пользователем и выводится на экран в строку. Найти максимальный и минимальный элементы массива.",
          "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tint arr[10];\n\n\tfor (int i = 0; i < 10; ++i) {\n\t\tcin >> arr[i];\n\t}\n\n\tint min = arr[0];\n\tint max = arr[0];\n\n\tfor (int i = 1; i < 10; i++) {\n\t\tif (arr[i] > max) {\n\t\t\tmax = arr[i];\n\t\t}\n\t\tif (arr[i] < min) {\n\t\t\tmin = arr[i];\n\t\t}\n\t}\n\n\tcout << \"Array: \";\n\tfor (int i = 0; i < 10; ++i) {\n\t\tcout << arr[i] << \"; \";\n\t}\n\tcout << endl;\n\n\tcout\n\t\t<< \"Min: \" << min << endl\n\t\t<< \"Max: \" << max << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Одномерный массив из 10 элементов задается пользователем и выводится на экран в строку. Найти сумму и среднее арифметическое элементов массива.",
          "solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tint arr[10];\n\n\tfor (int i = 0; i < 10; ++i) {\n\t\tcin >> arr[i];\n\t}\n\n\tdouble sum = 0;\n\n\tfor (int i = 0; i < 10; ++i) {\n\t\tsum += arr[i];\n\t}\n\n\tdouble avg = sum / 10.;\n\n\tcout << \"Array: \";\n\tfor (int i = 0; i < 10; ++i) {\n\t\tcout << arr[i] << \"; \";\n\t}\n\tcout << endl;\n\n\tcout\n\t\t<< \"Sum: \" << sum << endl\n\t\t<< \"Average: \" << avg << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Одномерный массив из 10 элементов задается пользователем и выводится на экран в строку. Найти произведение и среднее геометрическое элементов массива.",
          "solution": "#include <cmath>\n#include <iomanip>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tint arr[10];\n\n\tfor (int i = 0; i < 10; ++i) {\n\t\tcin >> arr[i];\n\t}\n\n\tlong double mul = 1.;\n\n\tfor (int i = 0; i < 10; ++i) {\n\t\tmul *= arr[i];\n\t}\n\n\tdouble geom = powl(mul, 1 / 10.);\n\n\tcout << \"Array: \";\n\tfor (int i = 0; i < 10; ++i) {\n\t\tcout << arr[i] << \"; \";\n\t}\n\tcout << endl;\n\n\tcout\n\t\t<< \"Product: \"        << mul << endl\n\t\t<< \"Geometric mean: \" << geom << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Двумерный массив 3 строки 4 столбца задается пользователем и выводится на экран в виде матрицы. Найти максимальный и минимальный элементы массива.",
          "solution": "#include <iomanip>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tint arr[3][4];\n\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tcin >> arr[i][j];\n\t\t}\n\t}\n\n\tint max = arr[0][0];\n\tint min = arr[0][0];\n\n\tcout << endl;\n\tcout << \"Array:\" << endl;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tif (max < arr[i][j]) {\n\t\t\t\tmax = arr[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tif (min > arr[i][j]) {\n\t\t\t\tmin = arr[i][j];\n\t\t\t}\n\n\t\t\tcout << setw(4) << arr[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\n\tcout\n\t\t<< \"Max: \" << max << endl\n\t\t<< \"Min: \" << min << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Двумерный массив 3 строки 4 столбца задается пользователем и выводится на экран в виде матрицы. Найти сумму и среднее арифметическое элементов массива.",
          "solution": "#include <iomanip>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tint arr[3][4];\n\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tcin >> arr[i][j];\n\t\t}\n\t}\n\n\tint sum = 0;\n\n\tcout << endl;\n\tcout << \"Array:\" << endl;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tsum += arr[i][j];\n\t\t\tcout << setw(3) << arr[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\n\tdouble avg = (double)sum / 12.;\n\n\tcout\n\t\t<< \"Sum: \"     << sum << endl\n\t\t<< \"Average: \" << avg << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        },
        {
          "question": "Двумерный массив 3 строки 4 столбца задается пользователем и выводится на экран в виде матрицы. Найти произведение и среднее геометрическое элементов массива.",
          "solution": "#include <cmath>\n#include <iomanip>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tsetlocale(LC_ALL, \"rus\");\n\n\tint arr[3][4];\n\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tcin >> arr[i][j];\n\t\t}\n\t}\n\n\tlong double mul = 1.;\n\n\tcout << endl;\n\tcout << \"Array:\" << endl;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\tmul *= (long double) arr[i][j];\n\t\t\tcout << setw(3) << arr[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\n\tdouble geom = powl(mul, 1 / 12.);\n\n\tcout\n\t\t<< \"Product: \" << mul << endl\n\t\t<< \"Geometric mean: \" << geom << endl;\n\n\tsystem(\"pause\");\n}",
          "type": "code"
        }
      ]
    }
  ]
}